This is udis86.info, produced by makeinfo version 4.8 from
./texinfo/udis86.texi.

Generated by Sphinx 1.1.3.
INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* udis86: (udis86.info). Disassembler library for x86.
END-INFO-DIR-ENTRY

     udis86 1.7.1, September 01, 2013

     Vivek Thampi

     Copyright (C) 2013, Vivek Thampi


File: udis86.info,  Node: Top,  Next: Getting Started,  Up: (dir)

udis86 Documentation
********************

     udis86 1.7.1, September 01, 2013

     Vivek Thampi

     Copyright (C) 2013, Vivek Thampi

* Menu:

* Getting Started::
* libudis86::
* Index::

 --- The Detailed Node Listing ---

Getting Started

* Building and Installing udis86::
* Interfacing with libudis86; A Quick Example: Interfacing with libudis86 A Quick Example.

libudis86

* ud_t; udis86 object: ud_t udis86 object.
* Setup Machine State::
* Setup Input::
* Setup Translation::
* Disassemble::
* Inspect Operands::
* Inspect Prefixes::


File: udis86.info,  Node: Getting Started,  Next: libudis86,  Prev: Top,  Up: Top

1 Getting Started
*****************

* Menu:

* Building and Installing udis86::
* Interfacing with libudis86; A Quick Example: Interfacing with libudis86 A Quick Example.


File: udis86.info,  Node: Building and Installing udis86,  Next: Interfacing with libudis86 A Quick Example,  Up: Getting Started

1.1 Building and Installing udis86
==================================

udis86 is developed for unix-like environments, and like most software,
the basic steps towards building and installing it are as follows.

    $ ./configure
    $ make
    $ make install

Depending on your choice of install location, you may need to have root
privileges to do an install. The install scripts copy the necessary
header and library files to appropriate locations in your system.


File: udis86.info,  Node: Interfacing with libudis86 A Quick Example,  Prev: Building and Installing udis86,  Up: Getting Started

1.2 Interfacing with libudis86: A Quick Example
===============================================

The following is an example of a program that interfaces with libudis86
and uses the API to generate assembly language output for 64-bit code,
input from STDIN.

    #include <stdio.h>
    #include <udis86.h>

    int main()
    {
        ud_t ud_obj;

        ud_init(&ud_obj);
        ud_set_input_file(&ud_obj, stdin);
        ud_set_mode(&ud_obj, 64);
        ud_set_syntax(&ud_obj, UD_SYN_INTEL);

        while (ud_disassemble(&ud_obj)) {
            printf("\t%s\n", ud_insn_asm(&ud_obj));
        }

        return 0;
    }

To compile the program (using gcc):

    $ gcc -ludis86 example.c -o example

This example should give you an idea of how this library can be used.
The following sections describe, in detail, the complete API of
libudis86.


File: udis86.info,  Node: libudis86,  Next: Index,  Prev: Getting Started,  Up: Top

2 libudis86
***********

libudis86 is a disassembler library for the x86 architecture, including
support for the newer 64bit variants (IA32e, amd64, etc.) It provides
you the ability to decode a stream of bytes as x86 instructions,
inspect various bits of information about those instructions and even
translate to human readable assembly language format.

* Menu:

* ud_t; udis86 object: ud_t udis86 object.
* Setup Machine State::
* Setup Input::
* Setup Translation::
* Disassemble::
* Inspect Operands::
* Inspect Prefixes::


File: udis86.info,  Node: ud_t udis86 object,  Next: Setup Machine State,  Up: libudis86

2.1 ud_t: udis86 object
=======================

libudis86 is reentrant, and to maintain that property it does not use
static data. All data related to the disassembly are stored in a single
object, called the udis86 object *note ud_t: 8.

 -- C Type: ud_t
     A structure encapsulating udis86 disassembler state.

  To use libudis86 you must create an instance of this object,

    ud_t ud_obj;

and initialize it,

    ud_init(&ud_obj);

You can create multiple such objects and use with the library, each one
an independent disassembler.


File: udis86.info,  Node: Setup Machine State,  Next: Setup Input,  Prev: ud_t udis86 object,  Up: libudis86

2.2 Setup Machine State
=======================

The decode semantics of a sequence of bytes depends on the target
machine state for which they are being disassembled. In x86, this means
the current effective processor mode (16, 32 or 64bits), the current
program counter (ip/eip/rip), and sometimes, the processor vendor. By
default, libudis86 is initialized to be in 32 bit disassembly mode,
program counter at 0, and vendor being `UD_VENDOR_ANY'.  The following
functions allow you to override these default to suit your needs.

 -- C Function: void ud_set_mode (ud_t*, uint8_t mode_bits)
     Sets the mode of disassembly. Possible values are 16, 32, and 64.
     By default, the library works in 32bit mode.

 -- C Function: void ud_set_pc (ud_t*, uint64_t pc)
     Sets the program counter (IP/EIP/RIP). This changes the offset of
     the assembly output generated, with direct effect on branch
     instructions.

 -- C Function: void ud_set_vendor (ud_t*, unsigned vendor)
     Sets the vendor of whose instruction to choose from. This is only
     useful for selecting the VMX or SVM instruction sets at which
     point INTEL and AMD have diverged significantly. At a later stage,
     support for a more granular selection of instruction sets maybe
     added.

        * `UD_VENDOR_INTEL' - for INTEL instruction set.

        * `UD_VENDOR_ATT' - for AMD instruction set.

        * `UD_VENDOR_ANY' - for any valid instruction in either INTEL
          or AMD.


File: udis86.info,  Node: Setup Input,  Next: Setup Translation,  Prev: Setup Machine State,  Up: libudis86

2.3 Setup Input
===============

libudis86 provides three ways in which you can input binary data: as a
fixed sized memory buffer, a standard library FILE object, or as a
callback function.  By default, a *note ud_t: 8. object is initialized
to read input from `STDIN'.

 -- C Function: void ud_set_input_buffer (ud_t*, unsigned char* buffer,
          size_t size)
     Sets the input source for the library to a `buffer' of `size'
     bytes.

 -- C Function: void ud_set_input_file (ud_t*, FILE* filep)
     Sets the input source to a file pointed to by a given standard
     library `FILE' pointer. Note that libudis86 does not perform any
     checks, and assumes that the file pointer is properly initialized
     and open for reading.

 -- C Function: void ud_set_input_hook (ud_t* ud_obj, int
          (*hook)(ud_t *ud_obj))
     Sets a pointer to a function, to callback for input. The callback
     is invoked each time libudis86 needs the next byte in the input
     stream. To single end-of-input, this callback must return the
     constant `UD_EOI'.

See also
........

     *note ud_set_user_opaque_data(): 11, *note
ud_set_user_opaque_data(): 11.

 -- C Function: void ud_input_skip(ud_t*, size_t n);
     Skips ahead `n' number of bytes in the input stream.

 -- C Function: int ud_input_end(const ud_t*);
     Test for end of input. You can use this function to test if udis86
     has exhausted the input.

  At the end of input, udis86 stops disassembly. If you want to restart
or reset the source of input, you must again invoke one of the above
functions.

  Sometimes you may want to associate custom data with a udis86 object,
that you can use with the input callback function, or even in different
parts of your own project as you pass the object around. You can use
the following two functions to achieve this.

 -- C Function: void ud_set_user_opaque_data (ud_t* ud_obj,
          void* opaque)
     Associates a pointer with the udis86 object to be retrieved and
     used in client functions, such as the input hook callback function.

 -- C Function: void* ud_get_user_opaque_data (const ud_t* ud_obj)
     Returns any pointer associated with the udis86 object, using the
     *note ud_set_user_opaque_data(): 11. function.


File: udis86.info,  Node: Setup Translation,  Next: Disassemble,  Prev: Setup Input,  Up: libudis86

2.4 Setup Translation
=====================

libudis86 can translate the decoded instruction into one of two assembly
language dialects: the INTEL syntax (such as those found in NASM and
YASM) and the other which resembles GNU Assembler (AT&T style) syntax.
By default, this is set to INTEL like syntax. You can override the
default or specify your own translator using the following function.

 -- C Function: void ud_set_syntax (ud_t*, void (*translator)(ud_t*))
     Sets the function that translates the intermediate decode
     information to a human readable form. There are two inbuilt
     translators,

        - `UD_SYN_INTEL' for INTEL (NASM-like) syntax. (default)

        - `UD_SYN_ATT' for AT&T (GAS-like) syntax.

     If you do not want libudis86 to translate, you can pass `NULL' to
     the function, with no more translations thereafter. This is useful
     when you only want to identify chunks of code and then create the
     assembly output if needed, or when you are only interested in
     examining the instructions and do not want to waste cycles
     generating the assembly language output.

     If you want to create your own translator, you can specify a
     pointer to your own function. This function must accept a single
     parameter, the udis86 object *note ud_t: 8, and it will be invoked
     everytime an instruction is decoded.


File: udis86.info,  Node: Disassemble,  Next: Inspect Operands,  Prev: Setup Translation,  Up: libudis86

2.5 Disassemble
===============

With target state and input source set up, you can now disassemble. At
the core of libudis86 api is the function *note ud_disassemble(): 16.
which does this.  libudis86 exposes decoded instructions in an
intermediate form meant to be useful for programs that want to examine
them. This intermediate form is available using functions and fields of
*note ud_t: 8. as described below.

 -- C Function: unsigned int ud_disassemble (ud_t*)
     Disassembles the next instruction in the input stream.

          Returns: the number of bytes disassembled. A 0 indicates end
          of input.

     Note, to restart disassembly after the end of input, you must call
     one of the input setting functions with a new source of input.

     A common use-case pattern for this function is in a loop:

         while (ud_disassemble(&ud_obj)) {
             /*
              * use or print decode info.
              */
         }



  For each successful invocation of *note ud_disassemble(): 16, you can
use the following functions to get information about the disassembled
instruction.

 -- C Function: unsigned int ud_insn_len (const ud_t* u)
     Returns the number of bytes disassembled.

 -- C Function: uint64_t ud_insn_off (const ud_t*)
     Returns the offset of the disassembled instruction in terms of the
     program counter value specified initially.

See also
........

     *note ud_set_pc(): b.

 -- C Function: const char* ud_insn_hex (ud_t*)
     Returns pointer to a character string holding the hexadecimal
     representation of the disassembled bytes.

 -- C Function: const uint8_t* ud_insn_ptr (const ud_t* u)
     Returns pointer to the buffer holding the instruction bytes. Use
     *note ud_insn_len(): 17. to determine the size of this buffer.

 -- C Function: const char* ud_insn_asm (const ud_t* u)
     If the syntax is specified, returns pointer to the character
     string holding assembly language representation of the
     disassembled instruction.

 -- C Function: const ud_operand_t* ud_insn_opr (const ud_t* u,
          unsigned int n)
     Returns a reference (*note ud_operand_t: 1d.) to the nth (starting
     with 0) operand of the instruction. If the instruction does not
     have such an operand, the function returns `NULL'.

 -- C Function: enum ud_mnemonic_code ud_insn_mnemonic (const ud_t *u)
     New in version 1.7.2.

     Returns the instruction mnemonic in the form of an enumerated
     constant (`enum ud_mnemonic_code'). As a convention all mnemonic
     constants are composed by prefixing standard instruction mnemonics
     with `UD_I'.  For example, the enumerations for `mov', `xor' and
     `jmp' are `UD_Imov', `UD_Ixor', and `UD_Ijmp', respectively.:

         ud_disassemble(&ud_obj);

         switch (ud_insn_mnemonic(ud_obj)) {
           case UD_Imov:  printf("mov!"); break;
           case UD_Ixor:  printf("xor!"); break;
           case UD_Ijmp:  printf("jmp!"); break;
           /*...*/
         }

     Prior to version 1.7.2, the way to access the mnemonic was by a
     field of `ud_t', `ud_t.mnemonc'. This field is now deprecated and
     may not be supported in the future.

See also
........

     `ud_lookup_mnemonic()'

 -- C Function: const char* ud_const lookup_mnemonic
          (enum ud_mnemonic_code)
     Returns a pointer to a character string corresponding to the given
     mnemonic code. Returns a `NULL' if the code is invalid.


File: udis86.info,  Node: Inspect Operands,  Next: Inspect Prefixes,  Prev: Disassemble,  Up: libudis86

2.6 Inspect Operands
====================

An intermediate representation of instruction operands is available in
the form of *note ud_operand_t: 1d. You can retrieve the nth operand of
a disassembled instruction using the function *note ud_insn_opr(): 1c.

 -- C Type: ud_operand_t
     The operand type, represents a single operand of an instruction. It
     contains the following fields.

        - *note size: 21.

        - *note type: 22.

        - *note base: 23.

        - *note index: 24.

        - *note scale: 25.

        - *note offset: 26.

        - *note lval: 27.

 -- C Member: unsigned ud_operand_t.size
     Size of the operand in number of bits.

 -- C Member: enum ud_operand_type ud_operand_t.type
     Type of the operand. Possible values are,

      -- C Variable: UD_OP_MEM
          A memory operand. The intermediate form normalizes all memory
          address equations to the scale-index-base form. The address
          equation is available in,

             - *note base: 23. - base register as an enumerated
               constant of type `enum ud_type'. Maybe `UD_NONE', in
               which case the memory addressing form does not include a
               base register.

             - *note index: 24. - index register as an enumerated
               constant of type `enum ud_type'. Maybe `UD_NONE', in
               which case the memory addressing form does not include
               an index register.

             - *note scale: 24. - an integer value by which the index
               register must be scaled. Maybe 0, denoting the absence of
               a scale component in the address.

             - *note offset: 26. - An integer value, which if non-zero
               represents the size of the displacement offset, and is
               one of 8, 16, 32, and 64. The value is available in
               *note lval: 27.

      -- C Variable: UD_OP_PTR
          A segment:offset pointer operand. The *note size: 21.  field
          can have two values, 32 (for 16:16 seg:off) and 48 (for 16:32
          seg:off).  The pointer value is available in *note lval: 27.
          (as *note lval.ptr.seg: 2a. and *note lval.ptr.off: 2b.)

      -- C Variable: UD_OP_IMM
          An Immediate operand. Value available in *note lval: 27.

      -- C Variable: UD_OP_JIMM
          An Immediate operand to a branch instruction (relative
          offsets). Value available in *note lval: 27.

      -- C Variable: UD_OP_CONST
          Implicit constant operand. Value available in *note lval: 27.

      -- C Variable: UD_OP_REG
          A register operand. The specific register is available in the
          *note base: 23. field as an enumerated constant of type `enum
          ud_type'.

 -- C Member: enum ud_register ud_operand_t.base
     Contains an enumerated constant of type `enum ud_type' representing
     a *note register: 2f. operand or the base of a *note memory: 28.
     operand.

 -- C Member: enum ud_register ud_operand_t.index
     Contains an enumerated constant of type `enum ud_type' representing
     the index register of a *note memory: 28. operand.

 -- C Member: unsigned ud_operand_t.scale
     Contains the scale component of a *note memory: 28. address
     operand.

 -- C Member: unsigned ud_operand_t.offset
     Contains the size of the displacement component of a *note memory:
     28. address operand. The displacement itself is given by *note
     lval: 27.

 -- C Member: ud_lval_t ud_operand_t.lval
     A union data structure that aggregates integer fields of different
     sizes, storing values depending on the *note type: 22. and *note
     size: 21. of the operand.

      -- C Member: lval.sbyte
          Signed Byte

      -- C Member: lval.ubyte
          Unsigned Byte

      -- C Member: lval.sword
          Signed Word

      -- C Member: lval.uword
          Unsigned Word

      -- C Member: lval.sdword
          Signed Double Word

      -- C Member: lval.udword
          Unsigned Double Word

      -- C Member: lval.sqword
          Signed Quad Word

      -- C Member: lval.uqword
          Unsigned Quad Word

      -- C Member: lval.ptr.seg
          Pointer Segment in Segment:Offset

      -- C Member: lval.ptr.off
          Pointer Offset in Segment:Offset

 -- C Type: enum ud_type
     Instruction Pointer

         UD_R_RIP

     8-Bit Registers

         UD_NONE,

         UD_R_AL,    UD_R_CL,    UD_R_DL,    UD_R_BL,
         UD_R_AH,    UD_R_CH,    UD_R_DH,    UD_R_BH,
         UD_R_SPL,   UD_R_BPL,   UD_R_SIL,   UD_R_DIL,
         UD_R_R8B,   UD_R_R9B,   UD_R_R10B,  UD_R_R11B,
         UD_R_R12B,  UD_R_R13B,  UD_R_R14B,  UD_R_R15B,

     16-Bit General Purporse Registers

         UD_R_AX,    UD_R_CX,    UD_R_DX,    UD_R_BX,
         UD_R_SP,    UD_R_BP,    UD_R_SI,    UD_R_DI,
         UD_R_R8W,   UD_R_R9W,   UD_R_R10W,  UD_R_R11W,
         UD_R_R12W,  UD_R_R13W,  UD_R_R14W,  UD_R_R15W,

     32-Bit General Purporse Registers:

         UD_R_EAX,   UD_R_ECX,   UD_R_EDX,   UD_R_EBX,
         UD_R_ESP,   UD_R_EBP,   UD_R_ESI,   UD_R_EDI,
         UD_R_R8D,   UD_R_R9D,   UD_R_R10D,  UD_R_R11D,
         UD_R_R12D,  UD_R_R13D,  UD_R_R14D,  UD_R_R15D,

     64-Bit General Purporse Registers:

         UD_R_RAX,   UD_R_RCX,   UD_R_RDX,   UD_R_RBX,
         UD_R_RSP,   UD_R_RBP,   UD_R_RSI,   UD_R_RDI,
         UD_R_R8,    UD_R_R9,    UD_R_R10,   UD_R_R11,
         UD_R_R12,   UD_R_R13,   UD_R_R14,   UD_R_R15,

     Segment Registers:

         UD_R_ES,    UD_R_CS,    UD_R_SS,    UD_R_DS,
         UD_R_FS,    UD_R_GS,

     Control Registers:

         UD_R_CR0,   UD_R_CR1,   UD_R_CR2,   UD_R_CR3,
         UD_R_CR4,   UD_R_CR5,   UD_R_CR6,   UD_R_CR7,
         UD_R_CR8,   UD_R_CR9,   UD_R_CR10,  UD_R_CR11,
         UD_R_CR12,  UD_R_CR13,  UD_R_CR14,  UD_R_CR15,

     Debug Registers:

         UD_R_DR0,   UD_R_DR1,   UD_R_DR2,   UD_R_DR3,
         UD_R_DR4,   UD_R_DR5,   UD_R_DR6,   UD_R_DR7,
         UD_R_DR8,   UD_R_DR9,   UD_R_DR10,  UD_R_DR11,
         UD_R_DR12,  UD_R_DR13,  UD_R_DR14,  UD_R_DR15,

     MMX Registers:

         UD_R_MM0,   UD_R_MM1,   UD_R_MM2,   UD_R_MM3,
         UD_R_MM4,   UD_R_MM5,   UD_R_MM6,   UD_R_MM7,

     FPU Registers:

         UD_R_ST0,   UD_R_ST1,   UD_R_ST2,   UD_R_ST3,
         UD_R_ST4,   UD_R_ST5,   UD_R_ST6,   UD_R_ST7,

     SSE Registers:

         UD_R_XMM0,  UD_R_XMM1,  UD_R_XMM2,  UD_R_XMM3,
         UD_R_XMM4,  UD_R_XMM5,  UD_R_XMM6,  UD_R_XMM7,
         UD_R_XMM8,  UD_R_XMM9,  UD_R_XMM10, UD_R_XMM11,
         UD_R_XMM12, UD_R_XMM13, UD_R_XMM14, UD_R_XMM15,




File: udis86.info,  Node: Inspect Prefixes,  Prev: Inspect Operands,  Up: libudis86

2.7 Inspect Prefixes
====================

Prefix bytes that affect the disassembly of the instruction are
availabe in the following fields, each of which corressponds to a
particular type or class of prefixes.

 -- C Member: uint8_t ud_t.pfx_rex
     64-bit mode REX prefix

 -- C Member: uint8_t ud_t.pfx_rex
     64-bit mode REX prefix

 -- C Member: uint8_t ud_t.pfx_seg
     Segment register prefix

 -- C Member: uint8_t ud_t.pfx_opr
     Operand-size prefix (66h)

 -- C Member: uint8_t ud_t.pfx_adr
     Address-size prefix (67h)

 -- C Member: uint8_t ud_t.pfx_lock
     Lock prefix

 -- C Member: uint8_t ud_t.pfx_rep
     Rep prefix

 -- C Member: uint8_t ud_t.pfx_repe
     Repe prefix

 -- C Member: uint8_t ud_t.pfx_repne
     Repne prefix

  These fields default to `UD_NONE' if the respective prefixes were not
found.


File: udis86.info,  Node: Index,  Prev: libudis86,  Up: Top

Index
*****

 [index ]
* Menu:

* lookup_mnemonic (C function):          Disassemble.         (line  94)
* lval.ptr.off (C member):               Inspect Operands.    (line 129)
* lval.ptr.seg (C member):               Inspect Operands.    (line 126)
* lval.sbyte (C member):                 Inspect Operands.    (line 102)
* lval.sdword (C member):                Inspect Operands.    (line 114)
* lval.sqword (C member):                Inspect Operands.    (line 120)
* lval.sword (C member):                 Inspect Operands.    (line 108)
* lval.ubyte (C member):                 Inspect Operands.    (line 105)
* lval.udword (C member):                Inspect Operands.    (line 117)
* lval.uqword (C member):                Inspect Operands.    (line 123)
* lval.uword (C member):                 Inspect Operands.    (line 111)
* ud_disassemble (C function):           Disassemble.         (line  13)
* ud_get_user_opaque_data (C function):  Setup Input.         (line  56)
* ud_insn_asm (C function):              Disassemble.         (line  56)
* ud_insn_hex (C function):              Disassemble.         (line  48)
* ud_insn_len (C function):              Disassemble.         (line  36)
* ud_insn_mnemonic (C function):         Disassemble.         (line  67)
* ud_insn_off (C function):              Disassemble.         (line  39)
* ud_insn_opr (C function):              Disassemble.         (line  61)
* ud_insn_ptr (C function):              Disassemble.         (line  52)
* UD_OP_CONST (C variable):              Inspect Operands.    (line  71)
* UD_OP_IMM (C variable):                Inspect Operands.    (line  64)
* UD_OP_JIMM (C variable):               Inspect Operands.    (line  67)
* UD_OP_MEM (C variable):                Inspect Operands.    (line  34)
* UD_OP_PTR (C variable):                Inspect Operands.    (line  58)
* UD_OP_REG (C variable):                Inspect Operands.    (line  74)
* ud_operand_t (C type):                 Inspect Operands.    (line  10)
* ud_operand_t.base (C member):          Inspect Operands.    (line  79)
* ud_operand_t.index (C member):         Inspect Operands.    (line  84)
* ud_operand_t.lval (C member):          Inspect Operands.    (line  97)
* ud_operand_t.offset (C member):        Inspect Operands.    (line  92)
* ud_operand_t.scale (C member):         Inspect Operands.    (line  88)
* ud_operand_t.size (C member):          Inspect Operands.    (line  28)
* ud_operand_t.type (C member):          Inspect Operands.    (line  31)
* ud_set_input_buffer (C function):      Setup Input.         (line  11)
* ud_set_input_file (C function):        Setup Input.         (line  16)
* ud_set_input_hook (C function):        Setup Input.         (line  22)
* ud_set_mode (C function):              Setup Machine State. (line  14)
* ud_set_pc (C function):                Setup Machine State. (line  18)
* ud_set_syntax (C function):            Setup Translation.   (line  12)
* ud_set_user_opaque_data (C function):  Setup Input.         (line  51)
* ud_set_vendor (C function):            Setup Machine State. (line  23)
* ud_t (C type):                         ud_t udis86 object.  (line  10)
* ud_t.pfx_adr (C member):               Inspect Prefixes.    (line  22)
* ud_t.pfx_lock (C member):              Inspect Prefixes.    (line  25)
* ud_t.pfx_opr (C member):               Inspect Prefixes.    (line  19)
* ud_t.pfx_rep (C member):               Inspect Prefixes.    (line  28)
* ud_t.pfx_repe (C member):              Inspect Prefixes.    (line  31)
* ud_t.pfx_repne (C member):             Inspect Prefixes.    (line  34)
* ud_t.pfx_rex (C member):               Inspect Prefixes.    (line  10)
* ud_t.pfx_seg (C member):               Inspect Prefixes.    (line  16)
* ud_type (C type):                      Inspect Operands.    (line 132)



Tag Table:
Node: Top334
Ref: index doc543
Ref: 0543
Node: Getting Started952
Ref: getstarted getting-started1037
Ref: 11037
Ref: getstarted doc1037
Ref: 21037
Node: Building and Installing udis861210
Ref: getstarted building-and-installing-udis861343
Ref: 31343
Node: Interfacing with libudis86 A Quick Example1810
Ref: getstarted interfacing-with-libudis86-a-quick-example1943
Ref: 41943
Node: libudis862797
Ref: libudis86 libudis862884
Ref: 52884
Ref: libudis86 doc2884
Ref: 62884
Node: ud_t udis86 object3414
Ref: libudis86 ud-t-udis86-object3506
Ref: 73506
Ref: libudis86 ud_t3746
Ref: 83746
Node: Setup Machine State4049
Ref: libudis86 setup-machine-state4161
Ref: 94161
Ref: libudis86 ud_set_mode4693
Ref: a4693
Ref: libudis86 ud_set_pc4875
Ref: b4875
Ref: libudis86 ud_set_vendor5083
Ref: c5083
Node: Setup Input5636
Ref: libudis86 setup-input5747
Ref: d5747
Ref: libudis86 ud_set_input_buffer6018
Ref: e6018
Ref: libudis86 ud_set_input_file6193
Ref: f6193
Ref: libudis86 ud_set_input_hook6490
Ref: 106490
Ref: libudis86 ud_set_user_opaque_data7586
Ref: 117586
Ref: libudis86 ud_get_user_opaque_data7813
Ref: 127813
Node: Setup Translation8003
Ref: libudis86 setup-translation8106
Ref: 138106
Ref: libudis86 ud_set_syntax8501
Ref: 148501
Node: Disassemble9479
Ref: libudis86 disassemble9587
Ref: 159587
Ref: libudis86 ud_disassemble10003
Ref: 1610003
Ref: libudis86 ud_insn_len10701
Ref: 1710701
Ref: libudis86 ud_insn_off10806
Ref: 1810806
Ref: libudis86 ud_insn_hex11025
Ref: 1911025
Ref: libudis86 ud_insn_ptr11188
Ref: 1a11188
Ref: libudis86 ud_insn_asm11386
Ref: 1b11386
Ref: libudis86 ud_insn_opr11600
Ref: 1c11600
Ref: libudis86 ud_insn_mnemonic11888
Ref: 1e11888
Ref: libudis86 lookup_mnemonic12822
Ref: 1f12822
Node: Inspect Operands13043
Ref: libudis86 inspect-operands13150
Ref: 2013150
Ref: libudis86 ud_operand_t13408
Ref: 1d13408
Ref: libudis86 ud_operand_t size13736
Ref: 2113736
Ref: libudis86 ud_operand_t type13822
Ref: 2213822
Ref: libudis86 UD_OP_MEM13923
Ref: 2813923
Ref: libudis86 UD_OP_PTR15040
Ref: 2915040
Ref: libudis86 UD_OP_IMM15353
Ref: 2c15353
Ref: libudis86 UD_OP_JIMM15452
Ref: 2d15452
Ref: libudis86 UD_OP_CONST15605
Ref: 2e15605
Ref: libudis86 UD_OP_REG15711
Ref: 2f15711
Ref: libudis86 ud_operand_t base15907
Ref: 2315907
Ref: libudis86 ud_operand_t index16114
Ref: 2416114
Ref: libudis86 ud_operand_t scale16294
Ref: 2516294
Ref: libudis86 ud_operand_t offset16416
Ref: 2616416
Ref: libudis86 ud_operand_t lval16615
Ref: 2716615
Ref: libudis86 lval sbyte16831
Ref: 3016831
Ref: libudis86 lval ubyte16884
Ref: 3116884
Ref: libudis86 lval sword16939
Ref: 3216939
Ref: libudis86 lval uword16992
Ref: 3316992
Ref: libudis86 lval sdword17047
Ref: 3417047
Ref: libudis86 lval udword17108
Ref: 3517108
Ref: libudis86 lval sqword17171
Ref: 3617171
Ref: libudis86 lval uqword17230
Ref: 3717230
Ref: libudis86 lval ptr seg17291
Ref: 2a17291
Ref: libudis86 lval ptr off17368
Ref: 2b17368
Ref: libudis86 ud_type17444
Ref: 3817444
Node: Inspect Prefixes19736
Ref: libudis86 inspect-prefixes19823
Ref: 3919823
Ref: libudis86 ud_t pfx_rex20035
Ref: 3a20035
Ref: libudis86 ud_t pfx_seg20163
Ref: 3b20163
Ref: libudis86 ud_t pfx_opr20228
Ref: 3c20228
Ref: libudis86 ud_t pfx_adr20295
Ref: 3d20295
Ref: libudis86 ud_t pfx_lock20362
Ref: 3e20362
Ref: libudis86 ud_t pfx_rep20416
Ref: 3f20416
Ref: libudis86 ud_t pfx_repe20468
Ref: 4020468
Ref: libudis86 ud_t pfx_repne20522
Ref: 4120522
Node: Index20658

End Tag Table
